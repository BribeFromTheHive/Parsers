<!DOCTYPE html>
<html>
    <head>
        <title>Bribe's vJass2Lua version 0.9 alpha</title>
    </head>
    <body>
        <input type="button" id="convert2lua" value="Convert to Lua"/>
        <input type="button" id="revert2vjass" value="Revert to vJass"/>
        <br/>
        <textarea rows="40" cols="120" id="scriptblock" placeholder="Enter vJass script"></textarea>
        <br />
        Configurables:
        <input type="checkbox" id="deletecomments">Delete comments
        <input type="checkbox" id="floordiv">Floor all division
        <br />
        <input type="checkbox" checked id="usehook">Enable Hook
    </body>
    <script>
        var recent = "";
        document.getElementById('revert2vjass').onclick = function() {
            var current = document.getElementById('scriptblock').value;
            if (recent != current && recent != "") {
                document.getElementById('scriptblock').value = recent;
            }
        }
        document.getElementById('convert2lua').onclick = function() {
            const vJassField = document.getElementById("scriptblock");
            const vJassSource = vJassField.value;
            var parsing = vJassSource;
            
            parsing = parsing.replace(/^([ \t]*)\/\/\![ \t]*novjass\b(.*?)^[ \t]*\/\/\![ \t]*\bendnovjass\b/gms, '$1--\[\[$2$1\]\]'); //novjass blocks
            parsing = parsing.replace(/\/\//g, '--'); //line comments
            parsing = parsing.replace(/\/\*(.*?)\*\/[ \t]*([ \t]*--.*?)*$/gms, '--\[\[$1\]\]$2'); //convert safe blockquotes (ones that are not breaking /**/ up /**/ text /**/ like /**/ this)
            parsing = parsing.replace(/\/\*.*?\*\//gms, ''); //delete all unsafe blockquotes

            parsing = parsing.replace(/^([ \t]*)debug[ \t]+(?:(?:set|call)[ \t])*/gm, '$1--'); //convert debug lines to comments
            parsing = parsing.replace(/^([ \t]*)(?:set|call|constant)[ \t]+/gm, '$1'); //these keywords don't exist in Lua
            parsing = parsing.replace(/^([ \t]*)static[ \t]+if\b/gm, '$1if'); //static-if is a vJass compile-time optimization, which Lua doesn't have.
            parsing = parsing.replace(/^[ \t]*native\b.*/gm, ''); //delete natives

            parsing = parsing.replace(/\b(do|in|end|for|nil|break|repeat|until|while)\b/g, '$1_'); //fix Lua keywords that aren't found in JASS.
            
            parsing = parsing.replace(/!=/g, '~=');
            parsing = parsing.replace(/\bnull\b/g, 'nil');
            parsing = parsing.replace(/\.exists\b/g, ''); //vJass feature is the same as simply evaluating the variable in Lua.
            parsing = parsing.replace(/'\\?(.)'/g, (_,char) => char.charCodeAt(0)); //convert 'a' into its integer equivalent
            parsing = parsing.replace(/('.*?')/g, 'FourCC($1)'); //Wrap "hfoo" in FourCC
            parsing = parsing.replace(/\"[ \t]*\+/g, '\"..'); //see below
            parsing = parsing.replace(/\+[ \t]*\"/g, '..\"'); //fix predictable string cocatenation

            parsing = parsing.replace(/\.([\$\w]+)[ \t]*\(/gm, '\:$1\('); //treat all x.method() as x:method() just in case we need to pass x as "self".
            parsing = parsing.replace(/^([ \t]*)\-\-\![ \t]*runtextmacro[ \t]+(?:optional)*[ \t]*(\w+)[ \t]*\((.*?)\)/gm, '$1vJass.runtextmacro(\"$2\", \{$3\})');

            parsing = parsing.replace(/^([ \t]*)interface\b[ \t]+([\$\w]+)(.*?)^[ \t]*endinterface/gm, '$1Struct $2 = vJass\.interface\(true\)\n$1--[[$3$1]]');
            
            const replaceArray1 = /^[ \t]*([\$\w]+)[ \t]+array[ \t]+([\$\w]+)(.*)/m;
            const replaceArray2 = /^[ \t]*\[[ \t]*(\d+)[ \t]*][ \t]*\[[ \t]*(\d+)[ \t]*]/m;
            const replaceArray3 = /^[ \t]*\[[ \t]*(\d+)[ \t]*]/m;
            const replaceVar1 = /^[ \t]*\b([\$\w]+)\b[ \t]+\b([\$\w]+)\b(.*)/m
            const replaceVar2 = /\-\-/
            const replaceVar3 = /^[ \t]*\=/m

            function parseVar(line) {
                //check for array declarations, first
                var newLine = line.replace(replaceArray1, function(_, type, name, remainder) {
                    type = "---@type "+type
                    var result = remainder.replace(replaceArray2, (_, width, height) =>
                        `${name} = vJass.array2D\(${width}, ${height}\) ---@type ${type}\[\]\[\]`
                    )
                    if (result == remainder) {
                        result = remainder.replace(replaceArray3, (_, size) => `${name} = \{size=${size}\}`);
                        if (result == remainder) {
                            return name + " = {} " + remainder;
                        }
                    }
                    return result;
                });
                if (newLine != line) {
                    return newLine; //array has been parsed
                }
                return line.replace(replaceVar1, function(_, type, name, remainder) {
                    var hasComment = remainder.search(replaceVar2);
                    var tail = "";
                    if (hasComment >= 0) {
                        tail = remainder.substring(hasComment);
                        remainder = remainder.substring(0, hasComment);
                    }
                    tail = " ---@type " + type + tail;
                    var isSet = remainder.search(replaceVar3);
                    if (isSet < 0) {
                        return name + " = nil " + tail; //simple variable declaration has been parsed
                    }
                    return name + remainder + tail; //variable with assignment has been parsed
                });
            }
            parsing = parsing.replace(/^([ \t]*local[ \t]+)(.*)/gm, (_, local, line) => local + parseVar(line));

            //parse scoped functions.
            parsing = parsing.replace(/^([ \t]*)(private|public)\b[ \t]+function[ \t]*([\$\w]+)(.*?^[ \t]*end)function/gm, function(_, indent, scope, name, body) {
                body = indent + "local function " +name + body
                if (scope == "public") {
                    return body + `\n${indent}_G[SCOPE_PREFIX..'${name}'] = name`;
                }
                return body;
            });
            parsing = parsing.replace(/^([ \t]*)private[ \t]+keyword\b/gm, '$1local');
            
            parsing = parsing.replace(/^([ \t]*)library[ \t]+(\w+)[ \t]*(?:initializer[ \t]*(\w*))?(.*?)endlibrary/gm, '($1)do\nlocal string SCOPE_PREFIX \= \"$2_\"\n--$4_G\[\"LIBRARY_\"..SCOPE_PREFIX] = true\nif \"$3\" \~\= \"\" then OnGlobalInit\($3\) end\nend');

            parsing = parsing.replace(/^([ \t]*)loop\s+exitwhen[ \t]*([^\r\n]*)\-\-/gms, '$1while not \($2\) do \-\-');
            parsing = parsing.replace(/^([ \t]*)loop\s+exitwhen[ \t]*([^\r\n]*)/gms, '$1while not \($2\) do');
            parsing = parsing.replace(/^([ \t]*)loop\b((?:(?!\bendloop\b|\bloop\b).)*?)^[ \t]*exitwhen([^\n\r]*)\s*?([ \t]*)endloop/gms, '$1repeat$2$4until$3');
            parsing = parsing.replace(/^([ \t]*)loop\b/gm, '$1while true do');
            parsing = parsing.replace(/^([ \t]*)exitwhen\b([^\r\n]*)\-\-/gm, '$1if$2 then break end \-\-');
            parsing = parsing.replace(/^([ \t]*)exitwhen\b([^\r\n]*)/gm, '$1if$2 then break end');
            parsing = parsing.replace(/^([ \t]*)if true then break end/gm, '$1break');
            
            parsing = parsing.replace(/^([ \t]*)hook[ \t]+(\w+)[ \t]+(\w*(?:\.\w+)*)/gm, '$1vJass\.hook\("$2"\, $3\)');

            parsing = parsing.replace(/^[ \t]*globals\b(.*?)\bendglobals\b/gms, function(_, globals) {
                globals = globals.replace(/^([ \t]*)private(?:[ \t]+constant)*\b/gm, '$1local');
                globals = globals.replace(/^([ \t]*)public[ \t]+constant[ \t]+([\$\w]+)[ \t]+([\$\w]+)([^\n\r]*)/gm, '$1local $2 $3$4\n$1_G\[SCOPE_PREFIX..\"$3\"\] \= $3');
                globals = globals.replace(/^([ \t]*)public[ \t]+([\$\w]+)[ \t]+([\$\w]+)\b([^\n\r]*)/gm, '$1local $2 $3$4\n$1GlobalRemap\(SCOPE_PREFIX..\"$3\"\, function\(\) return $3 end, function\(val\) $3 = val end\)');
                globals = globals.replace(/^([ \t]*(?:local[ \t]+)*)(.*)/gm, (_, prefix, remainder) => prefix + parseVar(remainder))
                return globals;
            });
            
            parsing = parsing.replace(/function[ \t]*([\$\w]+[\.]*[\w\$]*[ \t]*[\)\,])/, "$1");

            //parse textmacros
            const macroHasArgs = /^[ \t]takes[ \t]*(.*)/m;
            const getFirstLine = /\r?\n/;
            const macroWrapArgs = /\b\w+\b/g;
            parsing = parsing.replace(/^([ \t]*)\-\-\![ \t]*textmacro[ \t]+(\w+)(.*?)^[ \t]*\-\-\![ \t]*endtextmacro/gms, function(_, indent, name, body) {
                var statements = body.replace(macroHasArgs, "$1");
                if (statements != body) {
                    var linebreak = statements.search(getFirstLine);
                    body = statements;
                    statements = statements.substring(0, linebreak);
                    body = body.substring(linebreak);
                    statements = statements.replace(macroWrapArgs, function(arg) { return '\"'+arg+'\"'; });
                    return indent + 'vJass.textmacro(\"'+name+'\", {'+statements+'}, [['+body+indent+']])';
                }
                return indent + `vJass.textmacro("${name}", nil, function(thistype)${body}${indent}end)`;
            });

            //parse structs and modules similarly
            
            const isStructMember = /^([ \t]*)(static|readonly|public|private|method)[ \t]+(.*)/gm
            parsing = parsing.replace(/^([ \t]*)(private|public)*[ \t]*(struct|module)[ \t]*(.*?^[ \t]*end)(?:struct|module)/gms, function(_, indent, scope, strOrMod, body) {
                var linebreak = body.search(getFirstLine);
                var head = body.substring(0, linebreak);
                body = body.substring(linebreak);

                const isModule = (strOrMod == "module");

                //parse all easily-detectable variable and method declarations
                body = body.replace(isStructMember, function(_, indent, scope, line) {
                    if (scope != "static") {
                        line = line.replace(/^([ \t]*)static[ \t]*(?:constant[ \t]+)*/m, '$1') //remove any case of "static" and "constant".
                    }
                    var isMethod;
                    if (! isModule || scope != "private") {
                        isMethod = scope == "method"
                        scope = "thistype"; //only keep "private" for modules so the table knows to point to the module rather than to the implementing struct.
                    }
                    var operator;
                    if (isMethod || line.substring(0,6) == "method") {
                        line = line.replace(/^(?:method)*[ \t]*\b([\$\w]+)\b/m, function(_, name) {
                            if (name != "operator") {
                                return "function "+scope+":"+name;
                            } else {
                                operator = true;
                                return "";
                            }
                        });
                        if (operator) {
                            line = line.replace(/^[ \t]*(?:(\[[ \t]*\])|([\$\w]+))[ \t]*([=]*)[ \t]*(.*)/m, function(_, bracket, word, setter, remainder) {
                                if (bracket != undefined) {
                                    if (setter != "") {
                                        return "function thistype:_setindex("+remainder.replace(/takes[ \t]+[\$\w]+[ \t]+([\$\w]+)[ \t]*,[ \t]*[\$\w]+[ \t]*([\$\w]+\b|\$).*/, "$1, $2)");
                                    } else {
                                        return "function thistype:_getindex("+remainder.replace(/takes[ \t]+[\$\w]+[ \t]+([\$\w]+\b|\$).*/, '$1)');
                                    }
                                } else {
                                    if (setter != "") {
                                        return 'function thistype:_operatorset("'+word+'", '+remainder.replace(/takes[ \t]+[\$\w]+[ \t]+([\$\w]+\b|\$).*/, 'function(self, $1)');
                                    } else {
                                        return 'function thistype:_operatorget("'+word+'", function(self)';
                                    }
                                }
                            });
                        }
                    } else {
                        line = scope+'.'+parseVar(line);
                    }
                    return indent + line;
                });

                body = body.replace(/^([ \t]*function thistype:_operator.*?^[ \t]*end)method/gms, "$1)");
                body = body.replace(/^([ \t]*end)method/gm, "$1");

                if (isModule) {
                    head = head.replace(/([\$\w]+)/, `vJass.module("$1", "${scope}", SCOPE_PREFIX, function(private, thistype)\n${indent}    local Struct _ENV = Struct.environment(private)`);
                    body = body + ")";
                } else {
                    if (scope) {
                        head = head.replace(/([\$\w]+)/, "local $1 = Struct() --"); 
                    } else {
                        head = head.replace(/([\$\w]+)/, "$1 = Struct() --"); 
                    }
                }
                body = body.replace(/\bthis\b/g, 'self'); //implied 'this' in vJass doesn't work outside of structs, so we only need this replacer within a struct/module.
                body = body.replace(/([^\w\d\]\)])\.([A-Za-z])/gm, '$1self\.$2'); //dot-syntax doesn't work in Lua without something before the dot.
                body = body.replace(/^([ \t]*)implement[ \t]+([\$\w]+)/gm, '$1vJass.implement\(\"$2\", SCOPE_PREFIX, thistype\)');
                body = body.replace(/^([ \t]*)(public|private)[ \t]*static(?:[ \t]*constant)*[ \t]+/gm, function(_, indent, scope) {
                    if (scope == "") { scope == "thistype"; }
                    return indent+ scope+".";
                });
                if (! isModule) { body = "do" + body; }
                return indent + head + "\n" + indent + body;
            });

            parsing = parsing.replace(/^([ \t]*end)(?:loop|if|function)/gm, '$1')

            //parse function arguments
            const isNothing = /\bnothing\b/m;
            const getArgPairs = /([\$\w]+)[ \t]+([\$\w]+)/g;
            parsing = parsing.replace(/^([ \t]*)(.+)[ \t]+takes[ \t]+(.*)[ \t]+returns[ \t]+([\$\w]+)/gm, function(_, indent, func, params, rtype) {
                var paramEmmy = "";
                var returnEmmy = "";
                var argsResult = "";
                if (rtype != "nothing") {
                    returnEmmy = indent + "---\@return " + rtype + "\n";
                }
                if (! params.match(isNothing)) {
                    argsResult = params.replace(getArgPairs, function(_, type, name) {
                        paramEmmy += indent + "---\@param " + name + " " + type + "\n";
                        return name;
                    })
                }
                return paramEmmy + returnEmmy + indent + func + "(" + argsResult + ")";
            });
            
            recent = vJassSource;
            vJassField.value = parsing + "\n--Conversion by vJass2Lua v0.9.0.0 beta";
        }
    </script>
</html>
