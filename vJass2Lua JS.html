<!DOCTYPE html>
<html>
    <head>
        <title>Bribe's vJass2Lua version 0.9 alpha</title>
    </head>
    <body>
        <input type="button" id="convert2lua" value="Convert to Lua"/>
        <input type="button" id="revert2vjass" value="Revert to vJass"/>
        <br/>
        <textarea rows="40" cols="120" id="scriptblock" placeholder="Enter vJass script"></textarea>
        <br />
        Configurables:
        <input type="checkbox" id="deletecomments">Delete comments
        <input type="checkbox" id="floordiv">Floor all division
        <br />
        <input type="checkbox" checked id="useplugin">Enable vJass2Lua Runtime Plugin
        <br />
        <input type="checkbox" checked id="usehook">Enable Hook
    </body>
    <script>
        var recent = "";
        document.getElementById('revert2vjass').onclick = function() {
            var current = document.getElementById('scriptblock').value;
            if (recent != current && recent != "") {
                document.getElementById('scriptblock').value = recent;
            }
        }
        document.getElementById('convert2lua').onclick = function() {
            const vJassField = document.getElementById("scriptblock");
            const vJassSource = vJassField.value;
            var parsing = vJassSource;
            
            parsing = parsing.replace(/^([ \t]*)\/\/\![ \t]*novjass\b(.*?)^[ \t]*\/\/\![ \t]*\bendnovjass\b/gms, '$1--\[\[$2\]\]');
            parsing = parsing.replace(/\/\*(.*?)\*\/[ \t]*([ \t]*--.*?)*$/gms, '--\[\[$1\]\]$2');
            parsing = parsing.replace(/\/\//g, '--');
            parsing = parsing.replace(/\/\*.*?\*\//gms, ''); //delete all unsafe blockquotes

            parsing = parsing.replace(/^([ \t]*)debug[ \t]+(?:set|call)*/gm, '$1--');
            parsing = parsing.replace(/^([ \t]*)(?:set|call|constant)[ \t]+/gm, '$1');
            parsing = parsing.replace(/^([ \t]*)static[ \t]+if/gm, '$1if');
            parsing = parsing.replace(/^[ \t]*native\b.*/gm, '');

            parsing = parsing.replace(/^([ \t]*)\-\-\![ \t]*runtextmacro[ \t]+(?:optional)*[ \t]*(\w+)[ \t]*\((.*?)\)/gm, '$1vJass.runtextmacro(\"$2\", \{$3\})');
            parsing = parsing.replace(/!=/g, '~=');
            parsing = parsing.replace(/\bnull\b/g, 'nil');
            parsing = parsing.replace(/\.exists\b/g, '');
            parsing = parsing.replace(/'\\?(.)'/g, function(_,char) { return char.charCodeAt(0); });
            parsing = parsing.replace(/'.*?'/g, function(rawcode) { return `FourCC(${rawcode})`; });
            parsing = parsing.replace(/\"[ \t]*\+/g, '\"..');
            parsing = parsing.replace(/\+[ \t]*\"/g, '..\"');

            parsing = parsing.replace(/\bend\b/g, '_end');
            parsing = parsing.replace(/\.([\$\w]+)[ \t]*\(/gm, '\:$1\(');
            parsing = parsing.replace(/^([ \t]*)interface\b[ \t]+([\$\w]+)(.*?)^[ \t]*endinterface/gm, '$1Struct $2 = vJass\.interface\(true\)\n$1--[[$3$1]]');
            
            //parse scoped functions.
            parsing = parsing.replace(/^([ \t]*)(private|public)\b[ \t]+function[ \t]*([\$\w]+)(.*?^[ \t]*end)function/gm, function(str, indent, scope, name, body) {
                body = indent + "local function " +name + body
                if (scope == "public") {
                    return body + "\n"+indent+"_G[SCOPE_PREFIX..'"+name+"'] = " + name;
                }
                return body;
            });
            parsing = parsing.replace(/^([ \t]*)private[ \t]*keyword\b/gm, '$1local keyword');
            
            parsing = parsing.replace(/^([ \t]*)library[ \t]+(\w+)[ \t]*(?:initializer[ \t]*(\w*))?(.*?)endlibrary/gm, '($1)do\nlocal string SCOPE_PREFIX \= \"$2_\"\n--$4_G\[\"LIBRARY_\"..SCOPE_PREFIX] = true\nif \"$3\" \~\= \"\" then OnGlobalInit\($3\) end\nend');

            parsing = parsing.replace(/^([ \t]*)loop\s+exitwhen[ \t]*(.*?)\-\-/gms, '$1while not \($2\) do \-\-');
            parsing = parsing.replace(/^([ \t]*)loop\s+exitwhen[ \t]*(.*?)$/gms, '$1while not \($2\) do');
            parsing = parsing.replace(/^([ \t]*)loop\b((?:(?!\bendloop\b|\bloop\b).)*?)^[ \t]*exitwhen([^\n\r]*)\s*?([ \t]*)endloop/gms, '$1repeat$2$4until$3');
            parsing = parsing.replace(/^([ \t]*)loop\b/gm, '$1while true do');
            parsing = parsing.replace(/^([ \t]*)exitwhen\b(.*?)\-\-/gm, '$1if$2 then break end \-\-');
            parsing = parsing.replace(/^([ \t]*)exitwhen\b(.*?)/gm, '$1if$2 then break end');
            parsing = parsing.replace(/^([ \t]*)if true then break end/gm, '$1break');
            
            parsing = parsing.replace(/^[ \t]*globals\b(.*?)\bendglobals\b/gms, function(str, globals) {
                globals = globals.replace(/^([ \t]*)private(?:[ \t]+constant)*\b/gm, '$1local');
                globals = globals.replace(/^([ \t]*)public[ \t]+constant[ \t]+(\w+)[ \t]+(\w+)([^\n\r]*)/gm, '$1local $2 $3$4\n$1_G\[SCOPE_PREFIX..\"$3\"\] \= $3');
                globals = globals.replace(/^([ \t]*)public[ \t]+(\w+)[ \t]+(\w+)([^\n\r]*)/gm, '$1local $2 $3$4\n$1GlobalRemap\(SCOPE_PREFIX..\"$3\";\, function\(\) return $3 end, function\(val\) $3 = val end\)');
                return globals;
            });
            
            parsing = parsing.replace(/function[ \t]*(\w+[\.]*[\w]*[ \t]*[\)\,])/, "$1");

            //parse textmacros
            const macroHasArgs = /^[ \t]takes[ \t]*(.*)/m;
            const getFirstLine = /\r?\n/;
            const macroWrapArgs = /\b\w+\b/g;
            parsing = parsing.replace(/^([ \t]*)\-\-\![ \t]*textmacro[ \t]+(\w+)(.*?)^[ \t]*\-\-\![ \t]*endtextmacro/gms, function(str, indent, name, body) {
                var statements = body.replace(macroHasArgs, "$1");
                if (statements != body) {
                    var linebreak = statements.search(getFirstLine);
                    body = statements;
                    statements = statements.substring(0, linebreak);
                    body = body.substring(linebreak);
                    statements = statements.replace(macroWrapArgs, function(arg) { return '\"'+arg+'\"'; });
                    return indent + 'vJass.textmacro(\"'+name+'\", {'+statements+'}, [['+body+indent+']])';
                }
                return indent + "vJass.textmacro(\"" + name + "\", nil, function(thistype)" + body + indent + "end)";
            });
            
            //parse structs and modules similarly
            parsing = parsing.replace(/^([ \t]*)(private|public)*[ \t]*(struct|module)[ \t]*(.*?^[ \t]*end)(?:struct|module)/gms, function(str, indent, scope, strOrMod, body) {
                var linebreak = body.search(getFirstLine);
                var head = body.substring(0, linebreak);
                body = body.substring(linebreak);

                const isModule = (strOrMod == "module");

                //parse all easily-detectable variable and method declarations
                body = body.replace(/^([ \t]*)(static|readonly|public|private)[ \t]+(.*)/gm, function(_, indent, scope, line) {
                    if (scope != "static") {
                        line = line.replace(/^([ \t]*)static[ \t]*(?:constant[ \t]+)*/m, '$1') //remove any case of "static". It is not used in Lua and offers no additional utility.
                    }
                    if (! isModule || scope != "private") {
                        scope = "thistype";
                    }
                    if (line.substring(0,6) == "method") {
                        var operator = false;
                        line = line.replace(/^method[ \t]+(\w+)\b/m, function(_, name) {
                            if (name != "operator") {
                                return "function "+scope+":"+name;
                            } else {
                                operator = true;
                                return "";
                            }
                        });
                        if (operator) {
                            line = line.replace(/^[ \t]*(?:(\[[ \t]*\])|(\w+)\b)[ \t]*([=]*)[ \t]*(.*)/m, function(_, bracket, word, setter, remainder) {
                                if (bracket != "") {
                                    if (setter != "") {
                                        return "function thistype:_setindex("+remainder.replace(/takes[ \t]+[\$\w]+[ \t]+([\$\w]+)[ \t]*,[ \t]+[\$\w]+[ \t]*([\$\w]+)[ \t]+returns[ \t]+[\$\w]+/m, "$1, $2")+")"
                                    } else {
                                        return "function thistype:_getindex("+remainder.replace(/takes[ \t]+[\$\w]+[ \t]+([\$\w]+)[ \t]+returns[ \t]+[\$\w]+/m, '$1')+")"
                                    }
                                } else {
                                    if (setter != "") {

                                    } else {
                                        
                                    }
                                }
                            });
                        }
                    }
                    return indent + line;
                });
                if (isModule) {
                    head = head.replace(/([\$\w]+)/, 'vJass.module(\"$4\", \"$3\", SCOPE_PREFIX, function(private, public)\n$1    local Struct _ENV = Struct.environment(private)\n$1    local Struct thistype = public');
                    body = body + ")";
                } else {

                }
                if (scope == "public") {
                    head = "local struct "; 
                } else {
                    head = "local struct";
                }
                body = body.replace(/\bthis\b/g, 'self');
                body = body.replace(/([^\w\d\]\)])\.([A-Za-z])/gm, '$1self\.$2');
                body = body.replace(/^([ \t]*)implement[ \t]+([\$\w]+)/gm, '$1vJass.implement\(\"$2\", SCOPE_PREFIX, thistype\)');
                body = body.replace(/^([ \t]*)(?:static)*[ \t]*method[ \t]*operator[ \t]*([\$\w]+)[ \t]*takes[ \t]+nothing[ \t]+returns[ \t]+[\$\w]+(.*?end)method/gms, '$1thistype\:_operatorget\(\"$2\"\, function\(self\)$3\)');
                body = body.replace(/^([ \t]*)(public|private)[ \t]*static(?:[ \t]*constant)*[ \t]+/gm, function(str, indent, scope) {
                    if (scope == "") { scope == "thistype"; }
                    return indent+ scope+".";
                });
                return indent + head + "do"+ body;
            });

            parsing = parsing.replace(/^([ \t]*end)(?:method|loop|if|function)/gm, '$1')

            //parse function arguments
            const isNothing = /\bnothing\b/m;
            const getArgPairs = /([\$\w]+)[ \t]+([\$\w]+)/g;
            parsing = parsing.replace(/^([ \t]*)(.+)[ \t]+takes[ \t]+(.*)[ \t]+returns[ \t]+([\$\w]+)/gm, function(str, indent, func, params, rtype) {
                var paramEmmy = "";
                var returnEmmy = "";
                var argsResult = "";
                if (rtype != "nothing") {
                    returnEmmy = indent + "---\@return " + rtype + "\n";
                }
                if (! params.match(isNothing)) {
                    argsResult = params.replace(getArgPairs, function(str, type, name) {
                        paramEmmy += indent + "---\@param " + name + " " + type + "\n";
                        return name;
                    })
                }
                return paramEmmy + returnEmmy + indent + func + "(" + argsResult + ")";
            });
            
            recent = vJassSource;
            vJassField.value = parsing;
        }
    </script>
</html>